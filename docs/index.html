<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Oskar Wickström">
  <title>Property-Based Testing the Ugly Parts</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/owickstrom.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="highlight.js/styles/idea.css">
  <script src="highlight.js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Property-Based Testing the Ugly Parts</h1>
  <p class="author">Oskar Wickström</p>
  <p class="date">February 2019</p>
</section>

<section id="about-me" class="slide level2">
<h2>About Me</h2>
<ul>
<li>Live in Malmö, Sweden</li>
<li>Work for <a href="https://symbiont.io/">Symbiont</a></li>
<li>Blog at <a href="https://wickstrom.tech">wickstrom.tech</a></li>
<li>Maintain some open source projects</li>
<li><a href="https://haskell-at-work.com">Haskell at Work</a> screencasts</li>
<li>Spent the last year writing a screencast video editor</li>
</ul>
</section>
<section id="agenda" class="slide level2">
<h2>Agenda</h2>
<ul>
<li>Quick Introduction</li>
<li>Property-Based Testing for the Busy Programmer</li>
<li>Case Studies from Komposition</li>
</ul>
</section>
<section><section id="quick-introduction" class="title-slide slide level1"><h1>Quick Introduction</h1></section><section id="property-based-testing" class="slide level2">
<h2>Property-based testing</h2>
<ul>
<li>Testing <em>properties</em> of your system</li>
<li>Large set of inputs</li>
<li>Static and dynamic languages
<ul>
<li>QuickCheck</li>
<li>Hypothesis</li>
<li>test.check</li>
<li>Hedgehog</li>
</ul></li>
</ul>
</section><section id="simple-examples" class="slide level2">
<h2>Simple Examples</h2>
<ul>
<li><p>List reverse</p>
<p><span class="math inline">\(\forall x . \mathit{reverse}(\mathit{reverse}(x)) \to x\)</span></p></li>
<li><p>Addition commutativity</p>
<p><span class="math inline">\(\forall x\,y. (x+y) \to (y+x)\)</span></p></li>
<li><p>Sorting algorithms</p>
<p><span class="math inline">\(\forall x . \mathit{mySuperSort}(x) \to \mathit{industryStandardSort}(x)\)</span></p></li>
</ul>
</section><section id="hedgehog" class="slide level2">
<h2>Hedgehog</h2>
<ul>
<li>Random generated inputs</li>
<li>Integrated shrinking</li>
<li>Great error reporting</li>
<li>Concurrent test execution</li>
<li>Not using type classes(!)</li>
</ul>
</section><section id="list-reverse-with-hedgehog" class="slide level2">
<h2>List Reverse with Hedgehog</h2>
<pre class="haskell"><code>prop_reverse = property $ do
  xs &lt;- forAll $
    Gen.list
    (Range.linear 0 10)
    (Gen.int Range.linearBounded)
  reverse (reverse xs) === xs
</code></pre>
</section><section id="list-sort-with-hedgehog" class="slide level2">
<h2>List Sort with Hedgehog</h2>
<pre class="haskell"><code>prop_sort = property $ do
  xs &lt;- forAll $
    Gen.list
    (Range.linear 0 10)
    (Gen.int Range.linearBounded)
  mySuperSort xs === industryStandardSort xs
</code></pre>
</section><section id="failures" class="slide level2">
<h2>Failures</h2>
<p><img data-src="images/diff.png" /></p>
</section><section id="rhetorical-question" class="slide level2">
<h2>Rhetorical Question</h2>
<p>How many of you write sort algorithms in your day job?</p>
</section><section id="how-do-i-use-this-in-my-job" class="slide level2">
<h2>How do I use this in my job?</h2>
<ul>
<li>What if you’re working with:
<ul>
<li>Backends with databases and integrations?</li>
<li>Frontends with GUIs and user input?</li>
<li>Data pipelines and analytics?</li>
</ul></li>
<li>Hard to write properties</li>
<li>Fewer examples</li>
</ul>
</section></section>
<section><section id="property-based-testing-for-the-busy-programmer" class="title-slide slide level1 dark" data-background="images/dog.jpg"><h1>Property-Based Testing for the Busy Programmer</h1></section><section id="testing-the-ugly-parts" class="slide level2">
<h2>Testing the “Ugly” Parts</h2>
<ul>
<li>Not everything will be small pure functions</li>
<li>Complex interactions between larger modules</li>
<li>Stateful</li>
<li>Side-effects</li>
</ul>
</section><section id="designing-for-testability" class="slide level2">
<h2>Designing for Testability</h2>
<ul>
<li>Regular “writing testable code” guidelines apply:
<ul>
<li>Single responsibility</li>
<li>Determinism (not necessarily pure!)</li>
<li>No global side-effects</li>
</ul></li>
<li>Rich data types</li>
<li>Low coupling between interface and implementation</li>
</ul>
</section><section id="patterns-for-properties" class="slide level2">
<h2>Patterns for Properties</h2>
<ul>
<li><a href="https://fsharpforfunandprofit.com/posts/property-based-testing-2/">“Choosing properties for property-based testing”</a> by Scott Wlaschin
<ul>
<li>“Different paths, same destination”</li>
<li>“There and back again”</li>
<li>“Some things never change”</li>
<li>“The more things change, the more they stay the same”</li>
<li>“Solve a smaller problem first”</li>
<li>“Hard to prove, easy to verify”</li>
<li>“The test oracle”</li>
</ul></li>
</ul>
</section><section id="other-interesting-techniques" class="slide level2">
<h2>Other Interesting Techniques</h2>
<ul>
<li>State-machine testing</li>
<li>“Database of inputs”</li>
</ul>
</section></section>
<section><section id="case-studies-from-komposition" class="title-slide slide level1 dark" data-background="images/komposition-bg.png"><h1>Case Studies from Komposition</h1></section><section id="komposition" class="slide level2">
<h2>Komposition</h2>
<table>
<tr>
<td>
<ul>
<li>Cross-platform GUI application</li>
<li>Modal</li>
<li>Hierarchical timeline
<ul>
<li>Sequences</li>
<li>Parallels</li>
<li>Tracks</li>
<li>Clips and gaps</li>
</ul></li>
<li>Automatic scene classification</li>
<li>Automatic sentence classification</li>
<li>Keyboard-driven editing workflow
</td>
<td width="50%">
<img data-src="images/komposition-light.png" alt="Komposition" />
</td>
</tr>
</table></li>
</ul>
</section><section id="complex-features" class="slide level2">
<h2>Complex Features</h2>
<ul>
<li>Most complex features in Komposition
<ul>
<li>Focus and timeline transformations</li>
<li>Video classification</li>
<li>Rendering</li>
<li>Application logic</li>
</ul></li>
<li>Spend effort on testing those</li>
</ul>
</section><section id="case-studies" class="slide level2">
<h2>Case Studies</h2>
<ol type="1">
<li>Timeline Flattening</li>
<li>Video Scene Classification</li>
<li>Focus and Timeline Consistency</li>
<li>Undo/Redo Symmetry</li>
</ol>
</section></section>
<section><section id="hierarchical-timeline" class="title-slide slide level1" data-background="#dddddd"><h1>Hierarchical Timeline</h1></section><section id="clips" class="slide level2">
<h2>Clips</h2>
<p><img data-src="images/timeline1.svg" alt="Clips" style="width:80.0%" /></p>
<aside class="notes">
<ul>
<li>Clips are put in video and audio tracks within parallels</li>
<li>Tracks are played in parallel, hence the name</li>
</ul>
</aside>
</section><section id="video-still-frames" class="slide level2">
<h2>Video Still Frames</h2>
<p><img data-src="images/timeline2.svg" alt="Video Still Frames" style="width:80.0%" /></p>
<aside class="notes">
If the video track is shorter, it will be padded with still frames
</aside>
</section><section id="adding-gaps" class="slide level2">
<h2>Adding Gaps</h2>
<p><img data-src="images/timeline3.svg" alt="Adding Gaps" style="width:100.0%" /></p>
<aside class="notes">
<ul>
<li>You can add explicit gaps in video and audio tracks</li>
<li>These are also filled with still frames for video</li>
</ul>
</aside>
</section><section id="sequences" class="slide level2">
<h2>Sequences</h2>
<p><img data-src="images/timeline4.svg" alt="Sequences" style="width:100.0%" /></p>
<aside class="notes">
<ul>
<li>Parallels are put in sequences</li>
<li>Each parallel is played until its end, then the next, and so on</li>
<li>Multiple parallels can be used to synchronize clips</li>
</ul>
</aside>
</section><section id="timeline" class="slide level2">
<h2>Timeline</h2>
<p><img data-src="images/timeline5.svg" alt="Timeline" style="width:100.0%" /></p>
<aside class="notes">
<ul>
<li>The top level is the timeline</li>
<li>The timeline contain sequences</li>
<li>It’s useful for organizing the parts of your screencast</li>
</ul>
</aside>
</section></section>
<section><section id="case-study-1-timeline-flattening" class="title-slide slide level1"><h1><strong>Case Study 1:</strong> Timeline Flattening</h1></section><section id="timeline-flattening" class="slide level2">
<h2>Timeline Flattening</h2>
<ul>
<li>Timeline is hierarchical
<ul>
<li>Sequences</li>
<li>Parallels</li>
<li>Tracks</li>
<li>Clips and gaps</li>
</ul></li>
<li>FFmpeg render knows only about two flat tracks
<ul>
<li>Video track</li>
<li>Audio track</li>
</ul></li>
</ul>
</section><section id="timeline-flattening-graphical" class="slide level2">
<h2>Timeline Flattening (Graphical)</h2>
<p><img data-src="images/komposition-flattening.svg" alt="Timeline flattening" style="width:100.0%" /></p>
</section><section id="testing-duration" class="slide level2">
<h2>Testing Duration</h2>
<pre class="haskell"><code>hprop_flat_timeline_has_same_duration_as_hierarchical =
  property $ do
    t &lt;- forAll $ Gen.timeline (Range.exponential 0 20) Gen.parallelWithClips
    let Just flat = Render.flattenTimeline t
    <mark class="inline">durationOf AdjustedDuration t === durationOf AdjustedDuration flat</mark></code></pre>
</section><section id="testing-clip-occurence" class="slide level2">
<h2>Testing Clip Occurence</h2>
<pre class="haskell"><code>hprop_flat_timeline_has_same_clips_as_hierarchical =
  property $ do
    t &lt;- forAll $ Gen.timeline (Range.exponential 0 20) Gen.parallelWithClips
    let Just flat = Render.flattenTimeline t
    <mark class="inline">timelineVideoClips t === flatVideoClips flat</mark>
    <mark class="inline">timelineAudioClips t === flatAudioClips flat</mark></code></pre>
</section><section id="further-improvements" class="slide level2">
<h2>Further Improvements</h2>
<ul>
<li>Missing properties
<ul>
<li>How are video gaps padded with still frames?</li>
<li>Same flat result regardless of grouping (split/join sequences, then flatten)</li>
</ul></li>
<li>Padding with frames from other parallels
<ul>
<li>Frames are only picked from video clips within the parallel</li>
<li>Should pick from <em>any</em> video clip within the timeline</li>
<li>Write properties to guide my work</li>
</ul></li>
</ul>
</section></section>
<section><section id="case-study-2-video-scene-classification" class="title-slide slide level1"><h1><strong>Case Study 2:</strong> Video Scene Classification</h1></section><section id="video-scene-classification" class="slide level2">
<h2>Video Scene Classification</h2>
<ul>
<li>Komposition can automatically classify “scenes”
<ul>
<li><strong>Moving segment:</strong> at least <em>M</em> seconds of consecutive non-equal frames</li>
<li><strong>Still segment:</strong> at least <em>S</em> seconds of consecutive near-equal frames</li>
</ul></li>
<li><em>M</em> and <em>S</em> are preconfigured thresholds of moving and still segment durations</li>
</ul>
</section><section id="visualizing-with-color-tinting" class="slide level2">
<h2>Visualizing with Color Tinting</h2>
<p><img data-src="images/color-tinting.gif" alt="Video classification shown with color tinting" /></p>
</section><section id="testing-video-classification" class="slide level2">
<h2>Testing Video Classification</h2>
<ul>
<li>Generate high-level representation of <em>expected</em> output segments</li>
<li>Convert output representation to actual pixel frames
<ul>
<li>Moving frames: random color pixels</li>
<li>Still frames: all pixels with same color</li>
</ul></li>
<li>Run the classifier on the pixel frames</li>
<li>Test properties based on:
<ul>
<li>the expected output representation</li>
<li>the actual classified output</li>
</ul></li>
</ul>
</section><section id="two-properties-of-video-classification" class="slide level2">
<h2>Two Properties of Video Classification</h2>
<ol type="1">
<li>Classified still segments must be at least <em>S</em> seconds long
<ul>
<li>Exception: First and last segment may be shorter</li>
</ul></li>
<li>Classified moving segments must have correct timespans
<ul>
<li>Comparing the generated <em>expected</em> output to the classified timespans</li>
<li>Wrote this a week ago</li>
</ul></li>
</ol>
</section><section id="testing-still-segment-lengths" class="slide level2">
<h2>Testing Still Segment Lengths</h2>
<pre class="haskell"><code>hprop_classifies_still_segments_of_min_length = property $ do

  -- Generate test segments
  segments &lt;- forAll $
    genSegments (Range.linear 1 (frameRate * 2)) resolution

  -- Convert test segments to actual pixel frames
  let pixelFrames = testSegmentsToPixelFrames segments

  ...</code></pre>
</section><section id="testing-still-segment-lengths-cont." class="slide level2">
<h2>Testing Still Segment Lengths (cont.)</h2>
<pre class="haskell"><code>  ...

  -- Run classifier on pixel frames
  let counted = classifyMovement 1.0 (Pipes.each pixelFrames)
                &amp; Pipes.toList
                &amp; countSegments
  
  -- Sanity check: same number of frames
  countTestSegmentFrames segments === totalClassifiedFrames counted

  -- Then ignore first and last segment, and verify all other segments
  case dropFirstAndLast counted of
    Just middle -&gt; traverse_ (assertStillLengthAtLeast 1.0) middle
    Nothing     -&gt; success
  where
    resolution = 10 :. 10</code></pre>
</section><section id="success" class="slide level2">
<h2>Success!</h2>
<pre class="text"><code>&gt; Hedgehog.check hprop_classifies_still_segments_of_min_length 
  ✓ &lt;interactive&gt; passed 100 tests.</code></pre>
</section><section id="testing-moving-segment-timespans" class="slide level2">
<h2>Testing Moving Segment Timespans</h2>
<pre class="haskell"><code>hprop_classifies_same_scenes_as_input = property $ do

  -- Generate test segments
  segments &lt;- forAll 
    genSegments (Range.linear (frameRate * 1) (frameRate * 5)) resolution

  -- Convert test segments to timespanned ones, and actual pixel frames
  let segmentsWithTimespans = segments
                              &amp; map segmentWithDuration
                              &amp; segmentTimeSpans
      pixelFrames = testSegmentsToPixelFrames segments
      fullDuration = foldMap
                     (durationOf AdjustedDuration . unwrapSegment)
                     segmentsWithTimespans

  ...</code></pre>
</section><section id="testing-moving-segment-timespans-cont." class="slide level2">
<h2>Testing Moving Segment Timespans (cont.)</h2>
<pre class="haskell"><code>  ...

  -- Run classifier on pixel frames
  classified &lt;-
    (Pipes.each pixelFrames
     &amp; classifyMovement 1.0
     &amp; classifyMovingScenes fullDuration)
    &gt;-&gt; Pipes.drain
    &amp; Pipes.runEffect

  -- Check classified timespan equivalence
  unwrapScenes segmentsWithTimespans === classified

  where resolution = 10 :. 10</code></pre>
</section><section id="failure" class="slide level2">
<h2>Failure!</h2>
<p><img data-src="images/video-classification-failure.png" /></p>
</section><section id="what-went-wrong" class="slide level2">
<h2>What Went Wrong?</h2>
<ul>
<li>There were multiple bugs:
<ul>
<li>The specificiation was wrong</li>
<li>The generators and tests had errors</li>
<li>The implementation had errors (since its inception)</li>
</ul></li>
<li>Next steps:
<ul>
<li>Thought about the specification for a while</li>
<li>Thought about how generators and tests should work, rewrote them</li>
<li>Got minimal examples of failures, fixed the implementation</li>
</ul></li>
<li>Thousands of tests ran successfully</li>
<li>Tried importing actual recorded video, had great results!</li>
</ul>
</section></section>
<section><section id="case-study-3-focus-and-timeline-consistency" class="title-slide slide level1"><h1><strong>Case Study 3:</strong> Focus and Timeline Consistency</h1></section><section id="focus-and-timeline" class="slide level2">
<h2>Focus and Timeline</h2>
<ul>
<li>The <em>focus</em> is a data structure that “points” to a part of the timeline</li>
<li>The timeline and focus must at all points be consistent</li>
<li>User commands can:
<ul>
<li>alter the timeline</li>
<li>alter the focus</li>
</ul></li>
<li>Undo/redo complicates things</li>
</ul>
</section><section id="testing-focus-and-timeline-consistency" class="slide level2">
<h2>Testing Focus and Timeline Consistency</h2>
<ul>
<li>Generate a random initial state</li>
<li>Generate a random sequence user commands</li>
<li>Run all commands until termination
<ul>
<li>main control flow
<ul>
<li>entering/exiting modes</li>
</ul></li>
<li>state</li>
<li>event handling (stubbed)</li>
<li>effects (stubbed)</li>
</ul></li>
<li>Assert that the focus and timeline are consistent
<ul>
<li>Checking that “get the focused part” returns something</li>
</ul></li>
</ul>
</section><section id="focus-and-timeline-property-test" class="slide level2">
<h2>Focus and Timeline Property Test</h2>
<pre class="haskell"><code>hprop_focus_never_goes_invalid = property $ do

  -- Generate the initial timeline and focus
  timelineAndFocus &lt;- forAllWith
    showTimelineAndFocus
    (Gen.timelineWithFocus (Range.linear 0 10) Gen.parallel)

  -- And from those, the initial timeline mode state
  initialState &lt;- forAll (initializeState timelineAndFocus)
  
  -- Generate a sequence of events (user commands)
  events &lt;- forAll $
    Gen.list (Range.exponential 1 500) genFocusChangingEvents

  ...</code></pre>
</section><section id="focus-and-timeline-property-test-cont." class="slide level2">
<h2>Focus and Timeline Property Test (cont.)</h2>
<pre class="haskell"><code>  ...

  -- Run all the user commands (wrapped in events)
  endState &lt;- runTimelineStubbedWithExit (concat events) initialState

  -- Check that the focus points to something in the timeline
  assert . isJust $ atFocus
    (endState ^. existingProject.project.timelineFocus)
    (endState ^. existingProject.project.timeline.UndoRedo.current)</code></pre>
</section></section>
<section><section id="case-study-4-undoredo-symmetry" class="title-slide slide level1"><h1><strong>Case Study 4:</strong> Undo/Redo Symmetry</h1></section><section id="undoredo-symmetry" class="slide level2">
<h2>Undo/Redo Symmetry</h2>
<ul>
<li>Undo/Redo was previously implemented as stacks of previous/future states</li>
<li>Consumed gigabytes of disk space and RAM for projects with many edits</li>
<li>Rewrote the implementation to only store “invertible actions”</li>
</ul>
</section><section id="testing-undo" class="slide level2">
<h2>Testing Undo</h2>
<ul>
<li>Generate an initial state</li>
<li>Generate a sequence of undoable commands</li>
<li>Run all commands</li>
<li>Run undo command for each original command</li>
<li>Assert that we end up at the initial state</li>
</ul>
</section><section id="actions-are-undoable" class="slide level2">
<h2>Actions are Undoable</h2>
<pre class="haskell"><code>hprop_undo_actions_are_undoable = property $ do

  -- Generate initial timeline and focus
  timelineAndFocus &lt;- forAllWith showTimelineAndFocus $
    Gen.timelineWithFocus (Range.linear 0 10) Gen.parallel

  -- Generate initial application state
  initialState &lt;- forAll (initializeState timelineAndFocus)

  -- Generate a sequence of undoable/redoable commands
  events &lt;- forAll $
    Gen.list (Range.exponential 1 100) genUndoableTimelineEvent

  ...</code></pre>
</section><section id="actions-are-undoable-cont." class="slide level2">
<h2>Actions are Undoable (cont.)</h2>
<pre class="haskell"><code>  ...

  -- We begin by running &#39;events&#39; on the original state
  beforeUndos &lt;- runTimelineStubbedWithExit events initialState

  -- Then we run as many undo commands as undoable commands
  afterUndos &lt;- runTimelineStubbedWithExit (undoEvent &lt;$ events) beforeUndos

  -- That should result in a timeline equal to the one we at the
  -- beginning
  timelineToTree (initialState ^. currentTimeline)
    === timelineToTree (afterUndos ^. currentTimeline)</code></pre>
</section><section id="testing-redo" class="slide level2">
<h2>Testing Redo</h2>
<ul>
<li>Generate an initial state</li>
<li>Generate a sequence of undoable/redoable commands</li>
<li>Run all commands</li>
<li>Run undo <em>and redo</em> commands for each original command</li>
<li>Assert that we end up at the state before running undos</li>
</ul>
</section><section id="actions-are-redoable" class="slide level2">
<h2>Actions are Redoable</h2>
<pre class="haskell"><code>hprop_undo_actions_are_redoable = property $ do

  -- Generate the initial timeline and focus
  timelineAndFocus &lt;- forAllWith showTimelineAndFocus $
    Gen.timelineWithFocus (Range.linear 0 10) Gen.parallel
  
  -- Generate the initial application state
  initialState &lt;- forAll (initializeState timelineAndFocus)
  
  -- Generate a sequence of undoable/redoable commands
  events &lt;- forAll $
    Gen.list (Range.exponential 1 100) genUndoableTimelineEvent</code></pre>
</section><section id="actions-are-redoable-cont." class="slide level2">
<h2>Actions are Redoable (cont.)</h2>
<pre class="haskell"><code>  -- We begin by running &#39;events&#39; on the original state
  beforeUndos &lt;- runTimelineStubbedWithExit events initialState

  -- Then we undo and redo all of them
  afterRedos  &lt;-
    runTimelineStubbedWithExit (undoEvent &lt;$ events) beforeUndos
    &gt;&gt;= runTimelineStubbedWithExit (redoEvent &lt;$ events)

  -- That should result in a timeline equal to the one we had before
  -- starting the undos
  timelineToTree (beforeUndos ^. currentTimeline)
    === timelineToTree (afterRedos ^. currentTimeline)</code></pre>
</section><section id="undoredo-test-summary" class="slide level2">
<h2>Undo/Redo Test Summary</h2>
<ul>
<li>These tests made the refactoring possible</li>
<li>Founds <em>many</em> interim bugs
<ul>
<li>Off-by-one index</li>
<li>Inconsistent focus</li>
<li>Non-invertible actions</li>
</ul></li>
<li>After the tests passed: ran the GUI, it worked</li>
</ul>
</section></section>
<section><section id="wrapping-up" class="title-slide slide level1"><h1>Wrapping Up</h1></section><section id="summary" class="slide level2">
<h2>Summary</h2>
<ul>
<li>Property-based testing helps you:
<ul>
<li>run <em>more</em> test</li>
<li>express <em>properties</em> of your system, rather than <em>anecdotes</em></li>
<li>shrink down failures to <em>minimal examples</em></li>
<li>refactor and evolve existing functionality</li>
<li>write new functionality</li>
</ul></li>
<li>It’s most likely available for your language of choice</li>
<li>Using them in Komposition:
<ul>
<li>Made refactoring and evolving large parts of the system tractable and much more safe</li>
<li>Found existing errors in my thinking, my tests, my implementation</li>
<li>It’s been a joy</li>
</ul></li>
</ul>
</section><section id="references" class="slide level2">
<h2>References</h2>
<ul>
<li><a href="https://hypothesis.works/articles/what-is-property-based-testing/">What is Property Based Testing?</a> by David R. MacIver</li>
<li><a href="https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quviq-testing.pdf">Experiences with QuickCheck: Testing the Hard Stuff and Staying Sane</a> by John Hughes</li>
<li><a href="https://fsharpforfunandprofit.com/posts/property-based-testing-2/">“Choosing properties for property-based testing”</a> by Scott Wlaschin</li>
</ul>
</section><section id="questions" class="slide level2">
<h2>Questions?</h2>
</section><section id="thank-you" class="slide level2">
<h2>Thank You!</h2>
<ul>
<li>Komposition: <a href="https://owickstrom.github.io/komposition/">owickstrom.github.io/komposition/</a></li>
<li>Slides: <a href="https://owickstrom.github.io/property-based-testing-the-ugly-parts/">owickstrom.github.io/property-based-testing-the-ugly-parts/</a></li>
<li>Thanks to <a href="https://twitter.com/rjmh">John Hughes</a> for great feedback!</li>
<li>Image credits:
<ul>
<li><a href="https://knowyourmeme.com/photos/234765-i-have-no-idea-what-im-doing">I Have No Idea What I’m Doing</a></li>
</ul></li>
</ul>
</section></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,
        // Push each slide change to the browser history
        history: true,
        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom
        // Transition speed
        transitionSpeed: 'fast', // default/fast/slow
        math: {
          mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/math/math.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
